---
// src/components/BackgroundEffects.astro
---
<div id="bg-container">
    <canvas id="tech-canvas"></canvas>
    
    <div id="glass-overlay"></div>
    
    <div id="glow-overlay"></div>
</div>

<style>
    #bg-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
        overflow: hidden; /* Prevents scrollbars from parallax offsets */
    }

    #tech-canvas {
        position: absolute;
        width: 120%; /* Wider than screen to allow parallax movement without edges showing */
        height: 100%;
        left: -10%; /* Center the wider canvas */
        
        /* Removed CSS blur here, moved to glass overlay */
        opacity: 0.4;
        animation: brightenUp 2s ease-out forwards;
        will-change: opacity, transform;
    }

    /* 1. THE FROSTED GLASS EFFECT */
    #glass-overlay {
        position: absolute;
        inset: 0;
        z-index: 1;
        
        /* The Blur */
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);

        /* The Frost Texture (SVG Noise) */
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
        
        /* Blend mode to make it subtle */
        mix-blend-mode: overlay;
    }

    #glow-overlay {
        position: absolute;
        inset: 0;
        z-index: 2; /* Sits on top of glass */
        background: linear-gradient(
            to bottom, 
            rgba(255, 255, 255, 0.08) 0%, 
            transparent 25%, 
            transparent 75%, 
            rgba(255, 255, 255, 0.08) 100%
        );
    }

    @keyframes brightenUp {
        from { opacity: 0.4; }
        to { opacity: 0.8; } 
    }
</style>

<script>
    const canvas = document.getElementById('tech-canvas') as HTMLCanvasElement;
    const ctx = canvas.getContext('2d');

    let width, height;
    let strands = [];
    const EXTENSION = 300; 

    // --- PARALLAX STATE ---
    // Targets (where we want to be)
    let targetX = 0;
    let targetY = 0;
    
    // Current (where we are right now - for smoothing)
    let currentX = 0;
    let currentY = 0;

    // Mouse Listener
    window.addEventListener('mousemove', (e) => {
        // Normalize coordinates from -1 to 1
        const normX = (e.clientX / window.innerWidth) * 2 - 1;
        const normY = (e.clientY / window.innerHeight) * 2 - 1;
        
        targetX = normX * 100; // Max horizontal shift of 100px
        targetY = normY * 30;  // Max vertical shift of 30px
    });

    // Mobile Tilt Listener
    window.addEventListener('deviceorientation', (e) => {
        if (!e.gamma || !e.beta) return;
        
        // Gamma: Left/Right tilt (-90 to 90)
        // Beta: Front/Back tilt (-180 to 180)
        // Clamp values to avoid flipping at extreme angles
        const tiltX = Math.max(-45, Math.min(45, e.gamma));
        const tiltY = Math.max(-45, Math.min(45, e.beta));
        
        targetX = (tiltX / 45) * 100;
        targetY = (tiltY / 45) * 30;
    });
    
    // Mouse Interaction Physics (Separate from Parallax)
    let mouseX = -1000;
    let mouseSpeedX = 0;
    window.addEventListener('mousemove', (e) => {
        mouseSpeedX = e.movementX;
        mouseX = e.clientX;
    });

    const STRAND_COLOR = '255, 255, 255'; 

    class Strand {
        x: number;
        length: number;
        thickness: number;
        offset: number;
        amplitude: number;
        frequency: number;
        depth: number;
        strumVal: number; 
        strumVel: number; 
        highlight: number;
        
        alphaMult: number; 
        drawnDepth: number;
        
        // New: Parallax Factor (Front layers move more than back)
        parallaxFactor: number;

        constructor(index, totalStrands, layerCfg) {
            this.init(index, totalStrands, layerCfg);
        }

        init(index, totalStrands, layerCfg) {
            // Adjust canvas width calculation because canvas is 120% wide
            const effectiveWidth = width * 1.2; 
            const slotWidth = effectiveWidth / totalStrands;
            const slotStart = index * slotWidth;
            
            this.x = slotStart + (Math.random() * (slotWidth * 0.8)) + (slotWidth * 0.1);
            this.length = height + (EXTENSION * 2); 
            
            this.depth = Math.random();
            this.drawnDepth = this.depth + layerCfg.zOffset;
            this.alphaMult = layerCfg.alphaMult;
            
            // Assign Parallax Factor based on Z-Offset
            // Front (0) = 1.0, Middle (-1) = 0.5, Back (-2) = 0.2
            this.parallaxFactor = layerCfg.parallaxFactor;

            const baseThickness = (0.5 + (this.depth * 4)) * 10;
            this.thickness = baseThickness * layerCfg.thickMult;
            
            this.offset = Math.random() * 100; 
            this.amplitude = Math.random() * 50 + 20; 
            
            this.strumVal = 0;
            this.strumVel = 0;
            this.highlight = 0;
        }

        update() {
            this.offset += 0.005;

            // Physics
            const tension = 0.5; 
            const damping = 0.2; 
            const force = -tension * this.strumVal;
            this.strumVel += force;
            this.strumVel *= damping; 
            this.strumVal += this.strumVel;

            this.highlight *= 0.9; 

            // Calculate actual screen X including Parallax for interaction check
            // We need to reverse the parallax math to check if mouse hit the drawn line
            const drawX = this.x + (currentX * this.parallaxFactor);
            const dist = Math.abs(mouseX - (drawX - (width * 0.1))); // Adjust for canvas left -10% offset
            
            if (dist < (150 * this.alphaMult)) { 
                const depthImpact = 0.1 + (this.depth * 0.9);
                this.strumVel += (mouseSpeedX * 0.02) * depthImpact;
                this.highlight = Math.min(this.highlight + 0.1 + Math.abs(mouseSpeedX * 0.005), 1.0);
            }
        }

        draw() {
            if (!ctx) return;
            
            // APPLY PARALLAX
            // Shift X based on smoothed global X and this layer's speed factor
            // Shift Y slightly for subtle vertical tilt
            const finalX = this.x + (currentX * this.parallaxFactor);
            const finalYBase = (currentY * this.parallaxFactor * 0.5); // Less vertical movement

            ctx.beginPath();
            
            const baseMaxAlpha = 0.2 + (this.depth * 0.8);
            const finalMaxAlpha = baseMaxAlpha * this.alphaMult;

            // Gradient tracks the Y shift
            const grad = ctx.createLinearGradient(finalX, -EXTENSION + finalYBase, finalX, height + EXTENSION + finalYBase);
            grad.addColorStop(0, `rgba(${STRAND_COLOR}, 0)`);
            grad.addColorStop(0.1, `rgba(${STRAND_COLOR}, ${finalMaxAlpha})`); 
            grad.addColorStop(0.9, `rgba(${STRAND_COLOR}, ${finalMaxAlpha})`); 
            grad.addColorStop(1, `rgba(${STRAND_COLOR}, 0)`);

            ctx.strokeStyle = grad;
            ctx.lineWidth = this.thickness + (this.highlight * 2);
            ctx.lineCap = 'round';
            
            const segments = 25;
            const segmentHeight = this.length / segments;
            const startY = -EXTENSION + finalYBase;

            ctx.moveTo(
                finalX + Math.sin(this.offset) * this.amplitude, 
                startY
            );

            for (let i = 0; i <= segments; i++) {
                let currentSegY = startY + (segmentHeight * i);
                
                const ambientSway = Math.sin(this.offset + (i * 0.2)) * this.amplitude;
                const strumEffect = this.strumVal * Math.sin((i / segments) * Math.PI);
                
                ctx.lineTo(finalX + ambientSway + strumEffect, currentSegY);
            }

            ctx.shadowBlur = (5 + (this.highlight * 20)) * this.depth;
            ctx.shadowColor = `rgba(255, 255, 255, ${(0.5 + this.highlight * 0.5) * this.alphaMult})`;

            ctx.stroke();
            ctx.shadowBlur = 0; 
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        // Canvas is 120% width to hide edges during parallax
        canvas.width = width * 1.2;
        canvas.height = height;
        
        strands = [];
        const BASE_COUNT = Math.floor(Math.random() * 2) + 5;

        // Layer Config with Parallax Factors
        const layers = [
            // Back: Moves barely (0.2)
            { countMult: 2.25, thickMult: 0.25, alphaMult: 0.2, zOffset: -2, parallaxFactor: 0.2 },
            // Middle: Moves normally (0.5)
            { countMult: 1.5,  thickMult: 0.5,  alphaMult: 0.4, zOffset: -1, parallaxFactor: 0.5 },
            // Front: Moves a lot (1.2) - feels closest to "Camera"
            { countMult: 1.0,  thickMult: 1.0,  alphaMult: 0.8, zOffset: 0,  parallaxFactor: 1.2 }
        ];

        layers.forEach(layerCfg => {
            const layerCount = Math.round(BASE_COUNT * layerCfg.countMult);
            for (let i = 0; i < layerCount; i++) {
                strands.push(new Strand(i, layerCount, layerCfg));
            }
        });
    }

    function animate() {
        if (!ctx) return;
        
        // LERP (Linear Interpolation) for Smooth Parallax
        // This makes the movement feel "heavy" and smooth, not instant/jittery
        currentX += (targetX - currentX) * 0.05;
        currentY += (targetY - currentY) * 0.05;

        // Clear larger canvas area
        ctx.clearRect(0, 0, width * 1.2, height);

        strands.sort((a, b) => a.drawnDepth - b.drawnDepth);

        strands.forEach(strand => {
            strand.update();
            strand.draw();
        });
        
        mouseSpeedX = 0;

        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    animate();
</script>
