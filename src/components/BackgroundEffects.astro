---
// src/components/AuroraPulses.astro
---
<div id="bg-container">
    <canvas id="aurora-canvas"></canvas>
    <div id="atmosphere-overlay"></div>
</div>

<style>
    #bg-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
        overflow: hidden; 
        background: radial-gradient(circle at 50% 100%, #111b24, #000000); 
    }

    #aurora-canvas {
        position: absolute;
        width: 120%; 
        height: 100%;
        left: -10%; 
        filter: blur(40px) contrast(1.1);
        opacity: 0; 
        animation: fadeIn 3s ease-out forwards;
        will-change: opacity, transform;
    }

    #atmosphere-overlay {
        position: absolute;
        inset: 0;
        z-index: 1;
        opacity: 0.05;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
        mix-blend-mode: overlay;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; } 
    }
</style>

<script>
    const canvas = document.getElementById('aurora-canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let strands = [];
    
    // Huge extension to ensure ends are never seen
    const EXTENSION = 1200; 

    // --- PARALLAX STATE ---
    let targetX = 0;
    let currentX = 0;

    // Mouse Parallax (Desktop)
    window.addEventListener('mousemove', (e) => {
        const normX = (e.clientX / window.innerWidth) * 2 - 1;
        targetX = normX * 60; // 2x sensitivity (was 30)
    });

    // Device Orientation Parallax (Mobile)
    window.addEventListener('deviceorientation', (e) => {
        // e.gamma is left/right tilt in degrees (-90 to 90)
        if (e.gamma === null) return;
        
        // Clamp tilt to roughly +/- 25 degrees so you don't have to flip phone entirely
        const tilt = Math.min(Math.max(e.gamma, -25), 25);
        
        // Map tilt range to parallax range (-60 to 60)
        targetX = (tilt / 25) * 60;
    });

    // --- COLOR PALETTES ---
    const BASE_WHITE = [255, 255, 255]; 
    const PULSE_PALETTE = [
        [180, 255, 220],
        [200, 220, 255],
        [230, 245, 255]
    ];

    class Strand {
        constructor(index, totalStrands, layerCfg) {
            this.init(index, totalStrands, layerCfg);
        }

        init(index, totalStrands, layerCfg) {
            const effectiveWidth = width * 1.4; 
            const startX = -width * 0.2; 
            const slotWidth = effectiveWidth / totalStrands;
            
            this.x = startX + (index * slotWidth) + (Math.random() * slotWidth);
            this.length = height + (EXTENSION * 2); 
            
            this.depth = Math.random(); 
            this.drawnDepth = this.depth + layerCfg.zOffset;
            this.alphaMult = layerCfg.alphaMult;
            this.parallaxFactor = layerCfg.parallaxFactor;

            const baseThickness = 60 + (this.depth * 100); 
            this.thickness = baseThickness * layerCfg.thickMult;
            
            this.offset = Math.random() * 100; 
            
            // Settle Animation Props
            this.restAmplitude = Math.random() * 80 + 30; 
            this.settleAmplitude = Math.random() * 150 + 150; 
            this.settleTime = 0;
            this.settleDuration = 240 + Math.random() * 240;

            this.speed = (Math.random() * 0.0015) + 0.0005;

            this.pulsePhase = Math.random() * Math.PI * 2;
            this.pulseSpeed = (Math.random() * 0.01) + 0.005;
            this.pulseColorIdx = Math.floor(Math.random() * PULSE_PALETTE.length);
        }

        update() {
            this.offset += this.speed;
            this.pulsePhase += this.pulseSpeed;

            if (this.settleTime < this.settleDuration) {
                this.settleTime++;
            }
        }

        draw() {
            if (!ctx) return;
            
            const finalX = this.x + (currentX * this.parallaxFactor);
            const startY = -EXTENSION; // Starts way above screen

            const t = this.settleTime / this.settleDuration;
            const easeOut = 1 - Math.pow(1 - t, 3); 
            const currentAmp = this.restAmplitude + (this.settleAmplitude * (1 - easeOut));

            ctx.globalCompositeOperation = 'lighter';
            
            const segments = 40; 
            const segmentHeight = this.length / segments;

            ctx.beginPath();

            const centerPulseIntensity = Math.max(0, Math.sin(this.pulsePhase - Math.PI)); 

            const [wr, wg, wb] = BASE_WHITE;
            const [pr, pg, pb] = PULSE_PALETTE[this.pulseColorIdx];

            const r = wr + (pr - wr) * centerPulseIntensity;
            const g = wg + (pg - wg) * centerPulseIntensity;
            const b = wb + (pb - wb) * centerPulseIntensity;
            
            // --- BRIGHTNESS REDUCTION ---
            // We multiply all alpha values by 0.5 to cut brightness in half
            const GLOBAL_DIMMER = 0.5;

            // Was 0.4 min, now 0.2
            const minAlpha = (0.4 * this.alphaMult) * GLOBAL_DIMMER;
            // Pulse boost was 0.6, now 0.3
            const pulseBoost = (centerPulseIntensity * 0.6) * GLOBAL_DIMMER;
            
            const currentAlpha = Math.min(1, minAlpha + pulseBoost);

            const grad = ctx.createLinearGradient(finalX, startY, finalX, height + EXTENSION);
            grad.addColorStop(0, `rgba(${r},${g},${b}, ${minAlpha})`); 
            grad.addColorStop(0.3, `rgba(${r},${g},${b}, ${currentAlpha * 0.8})`);
            grad.addColorStop(0.5, `rgba(${r},${g},${b}, ${currentAlpha})`); 
            grad.addColorStop(0.7, `rgba(${r},${g},${b}, ${currentAlpha * 0.8})`);
            grad.addColorStop(1, `rgba(${r},${g},${b}, ${minAlpha})`);

            ctx.strokeStyle = grad;
            ctx.lineWidth = this.thickness * (1 + centerPulseIntensity * 0.3);
            ctx.lineCap = 'butt'; 
            
            ctx.moveTo(
                finalX + Math.sin(this.offset) * currentAmp, 
                startY
            );

            for (let i = 0; i <= segments; i++) {
                let currentSegY = startY + (segmentHeight * i);
                
                const wave1 = Math.sin(this.offset + (i * 0.08)) * currentAmp;
                const wave2 = Math.cos(this.offset * 2.3 + (i * 0.2)) * (currentAmp * 0.4);
                
                const taperBase = Math.sin((i / segments) * Math.PI); 
                const dynamicTaper = (taperBase * easeOut) + (0.5 * (1 - easeOut));

                const pulseWave = Math.sin(this.pulsePhase - (i * 0.3));
                const rippleIntensity = Math.pow(Math.max(0, pulseWave), 4); 
                const rippleEffect = rippleIntensity * (currentAmp * 0.4);

                ctx.lineTo(finalX + (wave1 + wave2 + rippleEffect) * dynamicTaper, currentSegY);
            }

            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * 1.2;
        canvas.height = height;
        
        strands = [];
        const BASE_COUNT = 6; 

        const layers = [
            { countMult: 0.6, thickMult: 0.8, alphaMult: 0.6, zOffset: -2, parallaxFactor: 0.1 },
            { countMult: 1.0, thickMult: 1.0, alphaMult: 0.9, zOffset: 0,  parallaxFactor: 0.2 },
            { countMult: 0.8, thickMult: 1.4, alphaMult: 1.0, zOffset: 2,  parallaxFactor: 0.4 }
        ];

        layers.forEach(layerCfg => {
            const layerCount = Math.round(BASE_COUNT * layerCfg.countMult);
            for (let i = 0; i < layerCount; i++) {
                strands.push(new Strand(i, layerCount, layerCfg));
            }
        });
    }

    function animate() {
        if (!ctx) return;
        
        currentX += (targetX - currentX) * 0.05; // Slightly snappier follow for mobile feel

        ctx.clearRect(0, 0, width * 1.2, height);

        strands.sort((a, b) => a.drawnDepth - b.drawnDepth);

        strands.forEach(strand => {
            strand.update();
            strand.draw();
        });
        
        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    animate();
</script>
