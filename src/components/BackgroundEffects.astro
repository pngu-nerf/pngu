---
// src/components/AuroraPulses.astro
---
<div id="bg-container">
    <canvas id="aurora-canvas"></canvas>
    <div id="atmosphere-overlay"></div>
</div>

<style>
    #bg-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
        overflow: hidden; 
        background: radial-gradient(circle at 50% 100%, #111b24, #000000); 
    }

    #aurora-canvas {
        position: absolute;
        width: 120%; 
        height: 100%;
        left: -10%; 
        
        /* Reduced blur slightly to keep the "pillar" definition visible at 50% opacity */
        filter: blur(40px) contrast(1.1);

        opacity: 0; 
        animation: fadeIn 3s ease-out forwards;
        will-change: opacity, transform;
    }

    #atmosphere-overlay {
        position: absolute;
        inset: 0;
        z-index: 1;
        opacity: 0.05;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
        mix-blend-mode: overlay;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; } 
    }
</style>

<script>
    const canvas = document.getElementById('aurora-canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let strands = [];
    const EXTENSION = 400; 

    // --- PARALLAX STATE ---
    let targetX = 0;
    let currentX = 0;

    window.addEventListener('mousemove', (e) => {
        const normX = (e.clientX / window.innerWidth) * 2 - 1;
        targetX = normX * 30; 
    });

    // --- COLOR PALETTES ---
    // Pure White Base
    const BASE_WHITE = [255, 255, 255]; 
    
    // Very light pastel pulses (high values prevent grayness)
    const PULSE_PALETTE = [
        [180, 255, 220],  // Pale Mint
        [200, 220, 255],  // Pale Periwinkle
        [230, 245, 255]   // Ice White
    ];

    class Strand {
        constructor(index, totalStrands, layerCfg) {
            this.init(index, totalStrands, layerCfg);
        }

        init(index, totalStrands, layerCfg) {
            const effectiveWidth = width * 1.4; 
            const startX = -width * 0.2; 
            const slotWidth = effectiveWidth / totalStrands;
            
            this.x = startX + (index * slotWidth) + (Math.random() * slotWidth);
            this.length = height + (EXTENSION * 2); 
            
            this.depth = Math.random(); 
            this.drawnDepth = this.depth + layerCfg.zOffset;
            this.alphaMult = layerCfg.alphaMult;
            this.parallaxFactor = layerCfg.parallaxFactor;

            const baseThickness = 60 + (this.depth * 100); 
            this.thickness = baseThickness * layerCfg.thickMult;
            
            // Movement properties
            this.offset = Math.random() * 100; 
            
            // --- SETTLE ANIMATION PROPS ---
            // restAmplitude: The "calm" state waviness (30-110)
            this.restAmplitude = Math.random() * 80 + 30; 
            // settleAmplitude: The "wild" initial waviness (extra 150-300px sway)
            this.settleAmplitude = Math.random() * 150 + 150; 
            this.settleTime = 0;
            // Takes between 4 to 8 seconds to settle completely
            this.settleDuration = 240 + Math.random() * 240; // 60fps * 4s = 240 frames

            this.speed = (Math.random() * 0.0015) + 0.0005;

            // Pulse props
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.pulseSpeed = (Math.random() * 0.01) + 0.005;
            this.pulseColorIdx = Math.floor(Math.random() * PULSE_PALETTE.length);
        }

        update() {
            this.offset += this.speed;
            this.pulsePhase += this.pulseSpeed;

            // Progress the settle timer
            if (this.settleTime < this.settleDuration) {
                this.settleTime++;
            }
        }

        draw() {
            if (!ctx) return;
            
            const finalX = this.x + (currentX * this.parallaxFactor);
            const startY = -EXTENSION;

            // --- CALCULATE DYNAMIC AMPLITUDE ---
            // Easing function (easeOutCubic) for smooth relaxation
            // t goes from 0 to 1
            const t = this.settleTime / this.settleDuration;
            const easeOut = 1 - Math.pow(1 - t, 3); 
            
            // Start at (Rest + Settle), gradually drop 'Settle' as easeOut approaches 1
            const currentAmp = this.restAmplitude + (this.settleAmplitude * (1 - easeOut));


            // Use lighter blending
            ctx.globalCompositeOperation = 'lighter';
            
            const segments = 40; 
            const segmentHeight = this.length / segments;

            ctx.beginPath();

            const centerPulseIntensity = Math.max(0, Math.sin(this.pulsePhase - Math.PI)); 

            const [wr, wg, wb] = BASE_WHITE;
            const [pr, pg, pb] = PULSE_PALETTE[this.pulseColorIdx];

            // Color Interpolation
            const r = wr + (pr - wr) * centerPulseIntensity;
            const g = wg + (pg - wg) * centerPulseIntensity;
            const b = wb + (pb - wb) * centerPulseIntensity;
            
            // Alpha Interpolation
            // 0.4 is the new minimum opacity (approx 50% visual weight)
            const minAlpha = 0.4 * this.alphaMult;
            const pulseBoost = centerPulseIntensity * 0.6; // Pulse adds another 60% opacity
            const currentAlpha = Math.min(1, minAlpha + pulseBoost);

            // Gradient:
            // Starts at 50% opacity, peaks in middle, ends at 50% opacity.
            // Never fades to 0.
            const grad = ctx.createLinearGradient(finalX, startY, finalX, height + EXTENSION);
            grad.addColorStop(0, `rgba(${r},${g},${b}, ${minAlpha})`); 
            grad.addColorStop(0.3, `rgba(${r},${g},${b}, ${currentAlpha * 0.8})`);
            grad.addColorStop(0.5, `rgba(${r},${g},${b}, ${currentAlpha})`); 
            grad.addColorStop(0.7, `rgba(${r},${g},${b}, ${currentAlpha * 0.8})`);
            grad.addColorStop(1, `rgba(${r},${g},${b}, ${minAlpha})`);

            ctx.strokeStyle = grad;
            ctx.lineWidth = this.thickness * (1 + centerPulseIntensity * 0.3);
            ctx.lineCap = 'butt'; 
            
            ctx.moveTo(
                finalX + Math.sin(this.offset) * currentAmp, 
                startY
            );

            for (let i = 0; i <= segments; i++) {
                let currentSegY = startY + (segmentHeight * i);
                
                const wave1 = Math.sin(this.offset + (i * 0.08)) * currentAmp;
                const wave2 = Math.cos(this.offset * 2.3 + (i * 0.2)) * (currentAmp * 0.4);
                
                // Taper makes the edges stick closer to center,
                // but we reduce taper effect during 'settle' so they fling wilder
                const taperBase = Math.sin((i / segments) * Math.PI); 
                // As it settles (easeOut -> 1), taper becomes strict. 
                // When wild (easeOut -> 0), taper is looser (0.5 minimum).
                const dynamicTaper = (taperBase * easeOut) + (0.5 * (1 - easeOut));

                const pulseWave = Math.sin(this.pulsePhase - (i * 0.3));
                const rippleIntensity = Math.pow(Math.max(0, pulseWave), 4); 
                const rippleEffect = rippleIntensity * (currentAmp * 0.4);

                ctx.lineTo(finalX + (wave1 + wave2 + rippleEffect) * dynamicTaper, currentSegY);
            }

            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * 1.2;
        canvas.height = height;
        
        strands = [];
        const BASE_COUNT = 6; 

        const layers = [
            { countMult: 0.6, thickMult: 0.8, alphaMult: 0.6, zOffset: -2, parallaxFactor: 0.1 },
            { countMult: 1.0, thickMult: 1.0, alphaMult: 0.9, zOffset: 0,  parallaxFactor: 0.2 },
            { countMult: 0.8, thickMult: 1.4, alphaMult: 1.0, zOffset: 2,  parallaxFactor: 0.4 }
        ];

        layers.forEach(layerCfg => {
            const layerCount = Math.round(BASE_COUNT * layerCfg.countMult);
            for (let i = 0; i < layerCount; i++) {
                strands.push(new Strand(i, layerCount, layerCfg));
            }
        });
    }

    function animate() {
        if (!ctx) return;
        
        currentX += (targetX - currentX) * 0.02; 

        ctx.clearRect(0, 0, width * 1.2, height);

        strands.sort((a, b) => a.drawnDepth - b.drawnDepth);

        strands.forEach(strand => {
            strand.update();
            strand.draw();
        });
        
        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    animate();
</script>
