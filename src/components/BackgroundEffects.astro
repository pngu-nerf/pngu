---
// src/components/AuroraBackground.astro
---
<div id="bg-container">
    <canvas id="aurora-canvas"></canvas>
    
    <div id="atmosphere-overlay"></div>
</div>

<style>
    #bg-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
        overflow: hidden; 
        /* Deep space background gradient */
        background: radial-gradient(circle at 50% 100%, #1a2a3a, #000000); 
    }

    #aurora-canvas {
        position: absolute;
        width: 120%; 
        height: 100%;
        left: -10%; 
        
        /* High blur is essential for the gaseous look */
        filter: blur(40px) contrast(1.2);

        opacity: 0.6;
        animation: fadeIn 3s ease-out forwards;
        will-change: opacity, transform;
    }

    #atmosphere-overlay {
        position: absolute;
        inset: 0;
        z-index: 1;
        opacity: 0.07;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
        mix-blend-mode: overlay;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 0.8; } 
    }
</style>

<script>
    const canvas = document.getElementById('aurora-canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let strands = [];
    
    // Auroras extend high up, so we need a large extension buffer
    const EXTENSION = 400; 

    // --- PARALLAX STATE ---
    let targetX = 0;
    let currentX = 0;

    window.addEventListener('mousemove', (e) => {
        // Subtle movement for parallax
        const normX = (e.clientX / window.innerWidth) * 2 - 1;
        targetX = normX * 50; 
    });

    // Auroras usually have these specific colors
    // [R, G, B]
    const PALETTE = [
        [0, 255, 128],  // Teal/Green (Low altitude)
        [100, 0, 255],  // Purple (Mid altitude)
        [0, 200, 255]   // Cyan (High brightness)
    ];

    class Strand {
        constructor(index, totalStrands, layerCfg) {
            this.init(index, totalStrands, layerCfg);
        }

        init(index, totalStrands, layerCfg) {
            // Spread across the screen
            const effectiveWidth = width * 1.4; // Wide spread
            const startX = -width * 0.2; 
            const slotWidth = effectiveWidth / totalStrands;
            
            // Position
            this.x = startX + (index * slotWidth) + (Math.random() * slotWidth);
            this.length = height + (EXTENSION * 2); 
            
            // Layers
            this.depth = Math.random(); 
            this.drawnDepth = this.depth + layerCfg.zOffset;
            this.alphaMult = layerCfg.alphaMult;
            this.parallaxFactor = layerCfg.parallaxFactor;

            // Aurora ribbons are THICK
            const baseThickness = 80 + (this.depth * 150); 
            this.thickness = baseThickness * layerCfg.thickMult;
            
            // Movement properties
            this.offset = Math.random() * 100; 
            // Large sweeping waves
            this.amplitude = Math.random() * 100 + 50; 
            this.speed = (Math.random() * 0.002) + 0.001;
            
            // Color selection (Green dominant, occasional purple)
            this.colorType = Math.random() > 0.7 ? 1 : 0; 
        }

        update() {
            // Constant slow drift
            this.offset += this.speed;
        }

        draw() {
            if (!ctx) return;
            
            const finalX = this.x + (currentX * this.parallaxFactor);
            const startY = -EXTENSION;

            // Use 'lighter' (additive) blending to make overlapping strands glow
            ctx.globalCompositeOperation = 'lighter';
            
            ctx.beginPath();
            
            // Dynamic Gradient based on strand color type
            const grad = ctx.createLinearGradient(finalX, startY, finalX, height + EXTENSION);
            
            const [r, g, b] = PALETTE[this.colorType];
            const [r2, g2, b2] = PALETTE[2]; // Cyan highlights

            // Alpha logic: Fades in, stays bright, fades out
            const maxAlpha = (0.15 + (this.depth * 0.2)) * this.alphaMult;

            grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0)`);
            grad.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, ${maxAlpha})`); 
            grad.addColorStop(0.5, `rgba(${r2}, ${g2}, ${b2}, ${maxAlpha * 0.8})`); 
            grad.addColorStop(0.8, `rgba(${r}, ${g}, ${b}, ${maxAlpha})`);
            grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.strokeStyle = grad;
            ctx.lineWidth = this.thickness;
            ctx.lineCap = 'butt'; // Soft ends handled by gradient, not shape
            
            const segments = 30;
            const segmentHeight = this.length / segments;

            ctx.moveTo(
                finalX + Math.sin(this.offset) * this.amplitude, 
                startY
            );

            for (let i = 0; i <= segments; i++) {
                let currentSegY = startY + (segmentHeight * i);
                
                // Double Sine Wave for more "organic" gas fluid movement
                // Wave 1: Large slow sweep
                const wave1 = Math.sin(this.offset + (i * 0.1)) * this.amplitude;
                // Wave 2: Smaller ripples
                const wave2 = Math.cos(this.offset * 2 + (i * 0.3)) * (this.amplitude * 0.3);
                
                // Taper the movement at top and bottom so they don't wiggle off screen too much
                const taper = Math.sin((i / segments) * Math.PI); 

                ctx.lineTo(finalX + (wave1 + wave2) * taper, currentSegY);
            }

            ctx.stroke();
            
            // Reset blend mode for safety (though we clear rect every frame)
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * 1.2;
        canvas.height = height;
        
        strands = [];
        // Fewer strands, but wider, creates the "curtain" look
        const BASE_COUNT = 7; 

        const layers = [
            { countMult: 0.5, thickMult: 0.8, alphaMult: 0.5, zOffset: -2, parallaxFactor: 0.1 },
            { countMult: 1.0, thickMult: 1.0, alphaMult: 0.8, zOffset: 0,  parallaxFactor: 0.3 },
            { countMult: 0.8, thickMult: 1.5, alphaMult: 1.0, zOffset: 2,  parallaxFactor: 0.6 }
        ];

        layers.forEach(layerCfg => {
            const layerCount = Math.round(BASE_COUNT * layerCfg.countMult);
            for (let i = 0; i < layerCount; i++) {
                strands.push(new Strand(i, layerCount, layerCfg));
            }
        });
    }

    function animate() {
        if (!ctx) return;
        
        currentX += (targetX - currentX) * 0.02; // Slower parallax

        ctx.clearRect(0, 0, width * 1.2, height);

        // Sort by depth preserves transparency logic
        strands.sort((a, b) => a.drawnDepth - b.drawnDepth);

        strands.forEach(strand => {
            strand.update();
            strand.draw();
        });
        
        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    animate();
</script>
